# Usage Guide for Style Library

## Overview

The Style Library allows you to pass styles as an array to the `style` prop of React Native components. It follows the principle that if multiple style objects are passed in an array and a key is present in multiple objects, the style from the last index of the array will override any previous occurrences of that key. This ensures a predictable and flexible approach to styling your components.

## Suggested Usage

```jsx
import { StyleLibrary } from 'your-style-library';

const MyComponent = () => {

  return (
    <TouchableOpacity style={[StyleLibrary.PrimaryButton, StyleLibrary.LargeButton]}>
      <Text style={StyleLibrary.textM, StyleLibrary.bold}>Click Me</Text>
    </TouchableOpacity>
  );
};
```

# General Ideas for Efficient Usage

## Direct Style Object Injection

When styles are injected directly as objects into the `style` prop, there's no need for class name resolution or parsing. This can reduce overhead and potentially lead to faster initial rendering.

## Avoiding Class Name Management

Libraries that use class names often involve additional overhead for managing and applying these class names to DOM elements. Direct injection of style objects bypasses this process altogether.

## Caching Styles

It's possible to cache styles generated by a library or even custom styles you've created. Caching can help improve performance by avoiding unnecessary re-computation of styles.

### Use Memoization

You can use memoization techniques to cache the result of style computations based on input parameters. This ensures that if the same styles are requested multiple times, the cached result is returned instead of recalculating them.

### Bundling Styles

You can bundle styles from your library along with your custom styles into a single object or file. This bundled styles object can then be efficiently injected into the `style` prop, reducing the overhead of managing multiple style sources.

## Performance Considerations

Using direct style object injection and caching styles can offer advantages over class name-based approaches, especially in scenarios where rendering performance is critical or where you have a large number of components with complex styling needs. However, the actual performance gains will depend on various factors such as the size and complexity of your application, the specific implementation of the libraries you're using, and the browser environment in which your application runs. It's always a good idea to profile and benchmark your application to evaluate the impact of different styling approaches on performance.

## Working with the StyleLibrary Locally
In this example, we import StyleLibrary from react-native-cascading-styles to access predefined styles. We also define a local style sheet called localStyles with a background color of yellow. We then combine StyleLibrary.borderM and localStyles into an array styles, with StyleLibrary.borderM being the first index. Finally, we inject styles directly into the style prop of the View component to apply the combined styles.

```jsx
import React from 'react';
import { View, Text, StyleSheets } from 'react-native';
import { StyleLibrary } from 'react-native-cascading-styles';

const MyComponent = () => {

  const localStyles = Stylesheet.create({
    viewStyle: {
        backgroundColor: 'yellow'
    }
  })

  return (
    <View style={[StyleLibrary.borderM, localStyles.viewStyle]}>
      <Text>This is my component styled with react-native-cascading-styles!</Text>
    </View>
  );
};

export default MyComponent;

```

```jsx
import React from 'react';
import { View, Text } from 'react-native';
import { StyleLibrary } from 'react-native-cascading-styles';
import { RowsAndColumns, IndividualBorderSides, FontWeights, FontSize } from './styles';

const App = () => {
  return (
    <View style={[RowsAndColumns.row, { backgroundColor: 'lightgray' }]}>
      <View style={[RowsAndColumns.col6, IndividualBorderSides.borderRightM]}>
        <Text style={[FontWeights.fontSemiBold, FontSize.textL, { color: 'blue' }]}>Column 1</Text>
      </View>
      <View style={[RowsAndColumns.col6, IndividualBorderSides.borderLeftM, { backgroundColor: 'lightblue' }]}>
        <Text style={[FontWeights.fontSemiBold, FontSize.textL, { color: 'red' }]}>Column 2</Text>
      </View>
    </View>
  );
};

export default App;
```
Working with StyleLibrary locally allows you to easily access predefined styles and combine them with your custom local styles. By following the convention of placing StyleLibrary styles at the beginning of the array and local styles at later indexes, you can ensure that your custom styles take precedence over predefined styles when necessary.

## Using StyleLibrary to build your own global styles and lighten load.

```jsx
// RowStyles.js
import { StyleSheet } from 'react-native';
import { StyleLibrary } from 'react-native-cascading-styles';

export const RowStyles = StyleSheet.create({
  row1: {
    ...StyleLibrary.flexRow,
    backgroundColor: 'lightblue',
  },
  row2: {
    ...StyleLibrary.flexRow,
    backgroundColor: 'lightgreen',
  },
  col1: {
    ...StyleLibrary.col6,
    backgroundColor: 'orange',
  },
  col2: {
    ...StyleLibrary.col6,
    backgroundColor: 'pink',
  },
});

```
```jsx
// App.tsx
import React from 'react';
import { View, Text } from 'react-native';
import { RowStyles } from './RowStyles';
import { ColumnStyles } from './ColumnStyles';

const App = () => {
  return (
    <View>
      <View style={RowStyles.row1}>
        <View style={ColumnStyles.col1}>
          <Text>Row 1, Column 1</Text>
        </View>
        <View style={ColumnStyles.col2}>
          <Text>Row 1, Column 2</Text>
        </View>
      </View>
      <View style={RowStyles.row2}>
        <View style={ColumnStyles.col1}>
          <Text>Row 2, Column 1</Text>
        </View>
        <View style={ColumnStyles.col2}>
          <Text>Row 2, Column 2</Text>
        </View>
      </View>
    </View>
  );
};

export default App;
```

Working with StyleLibrary this way can allow you to improve performance by building your style objects before users access your components. This can simplify the transaction at the app level and improve performance.

## Using Memoization to improve performance

Memoization is a technique used to optimize performance by caching the results of expensive function calls and returning the cached result when the same inputs occur again. In React, the useMemo hook is used to memoize the result of a function call and recompute the result only when the dependencies change.

```jsx
import React, { useMemo } from 'react';
import { View, Text } from 'react-native';
import { StyleLibrary } from 'react-native-cascading-styles';

// Define a function to generate styles based on input parameters
const generateStyles = (color) => {
  return {
    container: {
      ...StyleLibrary.flexCenter,
      backgroundColor: color,
      padding: 20,
    },
    text: {
      ...StyleLibrary.textL,
      ...StyleLibrary.fontSemiBold,
      color: 'white',
    },
  };
};

const MemoizedComponent = ({ color }) => {
  // Memoize the styles based on the input color
  const styles = useMemo(() => generateStyles(color), [color]);

  return (
    <View style={styles.container}>
      <Text style={styles.text}>Memoized Component</Text>
    </View>
  );
};

export default MemoizedComponent;

```

In the example above, we use useMemo to memoize the styles generated by the generateStyles function based on the color prop. This ensures that the styles are only re-generated when the color prop changes, reducing unnecessary computation and improving the performance of our component.

By memoizing styles, we can optimize the rendering process and create more efficient React components, especially in scenarios where styles are computed dynamically based on props or other input parameters.